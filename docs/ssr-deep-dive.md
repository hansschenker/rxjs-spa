# Server-Side Rendering (SSR) Deep Dive

The `@rxjs-spa` framework supports Server-Side Rendering (SSR) out of the box. This allows you to render your application to a string on the server, send it to the client, and then "hydrate" it to make it interactive.

## How it Works

The SSR process consists of two main phases:
1.  **Serialization (Server)**: The `renderToString` function traverses your template and produces an HTML string. Crucially, it injects **Markers** (e.g., `<!--__RX_0__-->`) into the HTML to identify where dynamic content (Observables, bindings) belongs.
2.  **Hydration (Client)**: The `hydrate` function traverses the DOM on the client. It uses the structure of the template (statics vs dynamics) to locate the nodes corresponding to the markers. It then attaches the reactive logic (subscriptions) to these nodes, effectively "waking up" the static HTML.

## Server-Side: `renderToString`

Located in `@rxjs-spa/ssr`, this function takes a `TemplateResult` (produced by the `html` tag) and returns a Promise that resolves to an HTML string.

```typescript
import { renderToString } from '@rxjs-spa/ssr'
import { html } from '@rxjs-spa/dom'
import { of } from 'rxjs'

const app = html`
  <h1>Hello, ${of('World')}!</h1>
`

const htmlString = await renderToString(app)
// Output: <h1>Hello, <!--__RX_0__-->World<!--__RX_0__END-->!</h1>
```

**Key Features:**
- **Async Resolution**: It waits for the *first emission* of any Observables in the template.
- **Markers**: Extensions like `__RX_0__` are inserted to tell the client where to attach bindings.

### Basic Server Example (Express)

```typescript
import express from 'express'
import { renderToString } from '@rxjs-spa/ssr'
import { App } from './app' // Your main component

const server = express()

server.get('*', async (req, res) => {
  const context = { url: req.url } // Mock router state usually
  const template = App(context)
  
  const content = await renderToString(template)
  
  const html = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>My SSR App</title>
        <script type="module" src="/client.js"></script>
      </head>
      <body>
        <div id="app">${content}</div>
      </body>
    </html>
  `
  
  res.send(html)
})
```

## Client-Side: `hydrate`

Located in `@rxjs-spa/dom`, `hydrate` is used instead of `mount` when the initial HTML is already present.

```typescript
import { hydrate } from '@rxjs-spa/dom'
import { App } from './app'

const root = document.getElementById('app')!
// The structure of App() MUST match what was rendered on the server
hydrate(root, App(window.location))
```

**Hydration Logic:**
1.  It prepares the template internals (parsing strings to find slots).
2.  It matches DOM nodes to these slots.
3.  It removes the SSR markers and static content generated by the server.
4.  It replaces them with the live, reactive nodes managed by the client-side Observables.

## Hydration Constraints

For hydration to work, the **template structure on the client must match the server exactly**.
If the server renders `<div>A</div>` but the client expects `<div>B</div>` (due to different initial state), hydration may fail or produce visual artifacts.

**Best Practices:**
- Ensure initial state (Stores) is synchronized. Serialize your Redux/Store state into `window.__INITIAL_STATE__` and read it on the client.
- Avoid accessing browser-specific APIs (`window`, `document`) during the initial render pass of your components, as this code runs on the server Node.js environment.
